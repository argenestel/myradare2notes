---
layout: default
title: Easy Crackme.
nav_order: 9
---

# Simple Crackmes
{: .no_toc }


So here are crackmes from <crackmes.one> very easy.
{: .fs-6 .fw-300 }

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

Programs are available in program directory in github. <https://argenestel.github.io/myradare2notes/programs/>

## First Program:

so i wrote a basic program in cpp

so the key will compare with a function and give us

in radare we can see.

```bash
r2 -d -AA program1
pdf @main
```

```terminal
...
|           0x55bc9633e193      8b45fc         movl var_4h, %eax
|           0x55bc9633e196      3d39050000     cmpl $0x539, %eax       ; rax
|       ,=< 0x55bc9633e19b b    7515           jne 0x55bc9633e1b2
|       |   0x55bc9633e19d      488d356c0e00.  leaq str.Access_Granted, %rsi ; 0x55bc9633f010 ; "Access Granted"
|       |   0x55bc9633e1a4      488d3dd52e00.  leaq reloc.std::cout, %rdi ; 0x55bc96341080
|       |   0x55bc9633e1ab      e8a0feffff     callq sym std::basic_ostream<char, std::char_traits<char> >& std::operator<< <std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const*) ; sym.imp.std::basic_ostream_char__std::char_traits_char_____std::operator____std::char_traits_char____std::basic_ostream_char__std::char_traits_char______char_const
|      ,==< 0x55bc9633e1b0      eb13           jmp 0x55bc9633e1c5
|      |`-> 0x55bc9633e1b2      488d35660e00.  leaq str.Access_Denied, %rsi ; 0x55bc9633f01f ; "Access Denied"
|      |    0x55bc9633e1b9      488d3dc02e00.  leaq reloc.std::cout, %rdi ; 0x55bc96341080
|      |    0x55bc9633e1c0      e88bfeffff     callq sym std::basic_ostream<char, std::char_traits<char> >& std::operator<< <std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const*) ; sym.imp.std::basic_ostream_char__std::char_traits_char_____std::operator____std::char_traits_char____std::basic_ostream_char__std::char_traits_char______char_const
|      |    ; CODE XREF from main @ 0x55bc9633e1b0
|      `--> 0x55bc9633e1c5      b800000000     movl $0, %eax
...
```
so we can see cmp between a value in hex and eax (the value from hex to decimal becomes 1337)
so hurray we solved the first crackme.

## Second Program:

So my second program went a bit long i can't really explain it whole but will cover major part.

First pass:-

```terminal
...
|           0x563a9c4cb26f      488d45a0       lea rax, qword [var_60h]
|           0x563a9c4cb273      4889c7         mov rdi, rax
|           0x563a9c4cb276      e8c5fdffff     call sym std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size() const ; sym.imp.std::__cxx11::basic_string_char__std::char_traits_char___std::allocator_char___::size___const
|           0x563a9c4cb27b b    4883f804       cmp rax, 4              ; 4
|           0x563a9c4cb27f      0f94c0         sete al
|           0x563a9c4cb282      84c0           test al, al
|       ,=< 0x563a9c4cb284      0f8461010000   je 0x563a9c4cb3eb
...
```

Let's Remove few parts and focus on important one.
There is a comparsion which can be a if statement and Before it we can see a function generated by
system contains size() so in cpp we usually have string.size().

Here is the take away:-

Using Debugger and setting break points we can get that var_60h is our Input <br />
There is a size comparsion<br />
So we need a variable of size 4

Fuzzing is possible but let's look on other things

```terminal
97042
[0x7f54cc8a0090]> dc
Input key
asdfa
hit breakpoint at: 55d44452d27b
[0x55d44452d27b]> dr
rax = 0x00000005
rbx = 0x00000000
```

okay so the first thing it checks is length when we see in visual mode we will get it more clearly.

So we basically bypass the first check.

Second Check:-

```terminal
...
|       |   0x563a9c4cb29b b    0fb618         movzx ebx, byte [rax]
|       |   0x563a9c4cb29e      488d45c0       lea rax, qword [var_40h]
|       |   0x563a9c4cb2a2      be0d000000     mov esi, 0xd            ; 13
|       |   0x563a9c4cb2a7      4889c7         mov rdi, rax
|       |   0x563a9c4cb2aa      e851feffff     call sym std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::operator[](unsigned long) ; sym.imp.std::__cxx11::basic_string_char__std::char_traits_char___std::allocator_char___::operator___unsigned_long
|       |   0x563a9c4cb2af      0fb600         movzx eax, byte [rax]
|       |   0x563a9c4cb2b2      38c3           cmp bl, al
|       |   0x563a9c4cb2b4      0f94c0         sete al
|       |   0x563a9c4cb2b7      84c0           test al, al
|      ,==< 0x563a9c4cb2b9      0f8417010000   je 0x563a9c4cb3d6
...
```

In second check we can see that  one byte of rax is moved into ebx so assuming rax as our input.
so we can see now ebx have first byte(bl as lower register).

Moving on as we can see var_40h is transfering address into rax.
esi <= 0xd (13) (some variable)
edi <= rax (address)

so one byte copied from rax => eax let's see what byte by px @(address)

```terminal
[0x563a9c4cb2af]> px @0x563a9e1bbebd
- offset -       0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
0x563a9e1bbebd  6e6f 7071 7273 7475 7677 7879 7a00 0000  nopqrstuvwxyz...
```
so bl will have n

cmp bl al
will set ZF and trigger je instruction.

so for passing this bl == al so if the first letter of input is n we can pass this check.

...

Till last iteration we need to do same as procedure second and we will have password.
